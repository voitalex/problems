--			 				A. —ледующий раунд
--
-- Ђ”частник выходит в следующий раунд соревнований, если он набрал не меньше баллов, 
-- чем участник, зан€вший k-е место, при условии, что набранное им число баллов строго 
-- положительно...ї Ч выдержка из правил соревнований.
--
-- ¬сего в соревновании было n участников (n <= k), и вам уже известны их баллы. ќпределите, 
-- сколько участников выйдет в следующий раунд.
--
-- ¬ходные данные
--
-- ¬ первой строке входных данных записаны два целых числа n и k (1 <= k, n <= 50), разделенных 
-- единичным пробелом.
--
-- ¬о второй строке записаны n целых чисел, разделенных единичными пробелами, a1, a2,..., an 
-- (0 <= ai <= 100), где ai Ч количество баллов, набранных участником на i-ом месте. „исла в 
-- заданной последовательности не возрастают (то есть дл€ всех i от 1 до n-1 выполн€етс€ 
-- ai >= ai+1).
--
-- ¬ыходные данные
--
-- ¬ыведите одно целое число Ч искомое количество участников, в соответствии с правилами.
--
-- ѕримеры тестов
--
-- ¬ходные данные
-- 8 5
-- 10 9 8 7 7 7 5 5
--
-- ¬ыходные данные
-- 6
--
-- ¬ходные данные
-- 4 2
-- 0 0 0 0
--
-- ¬ыходные данные
-- 0

import Control.Monad

toInt :: String -> Int
toInt = read

toTuple :: String -> (Int, Int)
toTuple s = ( head x, last x ) where x = ( (map (toInt) ) . words ) s
			
toList :: String -> [ Int ]
toList = ( (map (toInt) ) . words )

nextRound :: Int -> [ Int ] -> Int
nextRound _ [ ] = 0
nextRound n xs = length $ takeWhile (\x -> (x > 0) && (x >= n) ) xs
		
main = do
	strData <- getLine
	strNums <- getLine
	let lstNums = toList strNums
	print $ nextRound ( lstNums !! ( (snd $ toTuple strData) - 1 ) ) lstNums
	






